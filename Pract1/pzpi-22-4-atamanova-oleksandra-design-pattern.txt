Харківський університет радіоелектроніки
Факультет комп'ютерних наук
Кафедра програмної інженерії




ЗВІТ
до практичної роботи номер 1 з дисципліни 
"Архітектура програмного забезпечення"
на тему: "Патерни проєктування"




Виконала ст. гр. ПЗПІ-22-4
Атаманова Олександра Петрівна

Перевірив
ст. викладач кафедри ПІ
Сокорчук Ігор Петрович





Харків 2025

1 ІСТОРІЯ ЗМІН

№	Дата	Версія звіту	Опис змін та виправлень
1	10.03.2025	0.1	Створено розділи «Завдання», «Опис виконаної роботи» та «Висновки»
2	12.03.2025	0.2	Створено додатки «Додаток А», «Додаток Б», «Додаток В»

2 ЗАВДАННЯ 

Ознайомитися з патерном Decorator, зрозуміти його призначення та застосування, розглянути приклади реалізації на мові TypeScript. Продемонструвати використання декораторів для класів, методів, властивостей і параметрів.

3 ОПИС ВИКОНАНОЇ РОБОТИ

3.1 Теоретична частина

Патерн Decorator (Декоратор) являє собою структурний шаблон проєктування, що забезпечує динамічне розширення функціональності об'єктів шляхом додавання нових обов'язків без модифікації існуючого програмного коду.
Основними перевагами застосування патерну Decorator є:
– можливість розширення функціональності об'єктів у процесі виконання програми;
– забезпечення відповідності принципу відкритості/закритості (Open/Closed Principle);
– запобігання формуванню складних ієрархічних структур підкласів.
У контексті мови програмування TypeScript декоратори представлені спеціалізованим синтаксичним конструктом, що надає можливість модифікації поведінки наступних програмних елементів:
– класів;
– методів;
– властивостей;
– параметрів.
Дана реалізація забезпечує гнучкий механізм розширення функціональності програмних компонентів відповідно до принципів об'єктно-орієнтованого проєктування.

3.2 Приклади реалізації патерна Decorator на TypeScript

Код до кожного прикладу наведено у додатку В.

3.2.1 Декоратор класу
Патерн Decorator дозволяє змінювати поведінку класу без його зміни. У цьому прикладі, за допомогою декоратора Logger, ми додаємо функціональність логування до класу Person. При створенні нового об'єкта класу, викликається функція, яка виводить повідомлення в консоль, а також відображає сам конструктор. Це дозволяє відстежувати життєвий цикл об'єкта і є корисним для дебагу або моніторингу.
Декоратори класів дозволяють змінювати або додавати нову поведінку до класу без змін у його коді. Вони не змінюють сам клас, але можуть змінювати його властивості чи поведінку на етапі ініціалізації або в подальших операціях. Така особливість дуже корисна для створення гнучкої та масштабованої архітектури, особливо в контексті великих додатків.

3.2.2 Декоратор методу
Декоратор @Log надає можливість отримати інформацію про властивість класу під час її оголошення. У цьому випадку декоратор застосовується до сеттеру для властивості price класу Product. Він дозволяє логувати дані про властивість, наприклад, її назву та контекст, у якому вона оголошена.
Це дозволяє відстежувати, які саме властивості мають певну поведінку, додавати метаінформацію або підготувати клас до додаткових дій, наприклад, автоматичної валідації.
Варто зазначити, що цей декоратор викликається лише один раз — на етапі створення класу, а не під час кожного виклику або зміни значення властивості.
Декоратори методів і сеттерів у TypeScript використовуються для модифікації функцій або методів об'єктів. Вони дозволяють додавати, змінювати або розширювати функціональність без зміни основного коду методу. Це дуже корисно для задач валідації, логування, кешування або зміни поведінки методів.

3.2.3 Декоратор властивості
Декоратори властивостей дозволяють змінювати поведінку або додавати метаінформацію до конкретних полів класу. У наведеному прикладі, декоратор @Property застосовується до властивості title, щоб продемонструвати, як можна додавати додаткову логіку або метаінформацію для змінних.
Декоратори властивостей використовуються для додавання метаінформації або змін поведінки властивостей класу. Вони можуть бути використані для зміни типу або перевірки значень перед їх присвоєнням. Це особливо корисно при використанні валидацій чи обробки даних на етапі ініціалізації об'єкта.

3.2.4 Декоратор із параметрами (мінімальна довжина рядка)
У цьому прикладі реалізовано декоратор із параметрами MinLength, який перевіряє мінімальну довжину рядка, що присвоюється властивості. Декоратор приймає параметр — мінімальну кількість символів, яку повинен містити рядок. При ініціалізації властивості password виконується перевірка: якщо значення не є рядком або його довжина менша за вказану, виникає помилка. Таким чином, декоратор дозволяє легко організувати перевірку введених даних без потреби писати окремий код перевірки для кожного випадку.
Декоратори з параметрами надають можливість створювати гнучкі та багаторазові рішення для роботи з властивостями, методами або класами. Завдяки можливості передавати значення у вигляді параметрів, такі декоратори можуть бути налаштовані під конкретні потреби, що робить їх зручними для реалізації валідацій, обмежень і додаткової логіки у програмах.

3.2.5 Декоратор для методу з вимірюванням часу виконання
Цей декоратор дозволяє виміряти час виконання методу. За допомогою measure можна оцінити продуктивність функцій, особливо коли йдеться про складні або ресурсоємні операції. Цей підхід корисний для оптимізації коду, оскільки дозволяє автоматично фіксувати час виконання кожного виклику методу.
Декоратори для вимірювання часу виконання методів є корисними для моніторингу продуктивності додатків. Вони дозволяють автоматично вимірювати час виконання функцій без необхідності змінювати основний код методів. Це спрощує тестування, оптимізацію та моніторинг, а також дає можливість швидко виявити проблеми, що можуть виникнути через надмірне навантаження чи неефективність коду.

4 ВИСНОВКИ

У ході виконання роботи було детально розглянуто патерн проєктування Decorator, який є частиною структурних шаблонів проєктування. Патерн Decorator дозволяє динамічно розширювати функціональність класів, методів і властивостей без модифікації їх вихідного коду, що забезпечує дотримання принципу відкритості/закритості (Open/Closed Principle). Це особливо корисно при розробці масштабованих і гнучких архітектур, де необхідно додавати нові функціональності до класів, не змінюючи їх безпосередньо.
У межах даного завдання було розглянуто різні види декораторів у TypeScript:
– декоратор класу змінює поведінку класу або додає нові функціональні можливості до нього, не змінюючи внутрішню реалізацію, наприклад, для моніторингу створення екземплярів класу;
– декоратор методу дозволяє розширювати функціональність окремих методів, наприклад, додаючи валідацію, логування чи кешування;
– декоратор властивості змінює поведінку або додає метаінформацію для полів класу, дозволяючи, наприклад, здійснювати валідацію значень властивостей;
– декоратор із параметрами дозволяє створювати універсальні правила з налаштуванням через параметри, наприклад, для валідації мінімальної довжини рядка;
– декоратор для вимірювання часу виконання методу оцінює ефективність функцій, автоматично фіксуючи час виконання без зміни основного коду.
Таким чином, патерн Decorator є потужним і гнучким інструментом для розширення функціональності класів та методів без зміни їх вихідного коду. Використання декораторів в сучасних фреймворках, таких як NestJS і Angular, сприяє створенню чистого, гнучкого та підтримуваного коду, що є важливим аспектом в розробці великих і складних програмних систем.

ДОДАТОК А
(посилання на відеозапис доповіді та текст хронологічного опису доповіді)

Відеозапис доповіді на YouTube: https://youtu.be/5SATHB2kM-o
Хронологічний опис доповіді:
00:00 Знайомство 
00:21 Зміст доповіді
00:38 Завдання доповіді
00:58 Теоретичний опис патерну Декоратор
02:02 Приклад реалізації декоратора класу
02:39 Призначення та особливості декоратора класу
03:05 Приклад реалізації декоратора методу
03:38 Призначення та особливості декоратора методу
04:09 Приклад реалізації декоратора властивості
04:32 Призначення та особливості декоратора властивості
04:51 Приклад реалізації декоратора із параметрами
05:27 Призначення та особливості декоратора із параметрами
05:51 Приклад реалізації декоратора для методу з вимірюванням часу виконання
06:17 Призначення та особливості декоратора для методу з вимірюванням часу виконання
06:45 Висновки

ДОДАТОК Б
(слайди презентації доповіді)
 
Рисунок Б.1 – Вступ доповіді

Рисунок Б.2 – Зміст доповіді
  
Рисунок Б.3 – Завдання доповіді

Рисунок Б.4 – Теоретична частина

Рисунок Б.5 – Приклад декоратора класу

Рисунок Б.6 – Опис декоратора класу

Рисунок Б.7 – Приклад декоратора методу

Рисунок Б.8 – Опис декоратора методу
 
Рисунок Б.9 – Приклад декоратора властивості

Рисунок Б.10 – Опис декоратора властивості
  
Рисунок Б.11 – Приклад декоратора із параметрами

Рисунок Б.12 – Опис декоратора із параметрами

Рисунок Б.13 –Приклад декоратора для методу з вимірюванням часу виконання

Рисунок Б.14 – Опис декоратора для методу з вимірюванням часу виконання

Рисунок Б.15 – Висновки
 
ДОДАТОК В
(приклади програмного коду)

В.1 Декоратор класу
1 	function Logger(logString: string) {
2 	    return function(constructor: Function) {
3 	      console.log(logString);
4 	      console.log(constructor);
5 	    };
6 	  }
7 	  
8 	  @Logger('LOGGING - PERSON')
9 	  class Person {
10 	    name = 'Max';
11 	  
12 	    constructor() {
13 	      console.log('Creating person object...');
14 	    }
15 	  }
16 	
17 	  const person = new Person();


В.2 Декоратор методу
1 	function Log() {
2 	    return function (target: any, context: ClassSetterDecoratorContext) {
3 	        console.log('Method decorator!');
4 	        console.log(target);
5 	        console.log(context);
6 	    }
7 	}
8 	
9 	class Product {
10 	    title: string;
11 	    private _price: number;
12 	
13 	    @Log()
14 	    set price(val: number) {
15 	        if (val > 0) {
16 	            this._price = val;
17 	        } else {
18 	            throw new Error('Invalid price - should be positive!');
19 	        }
20 	    }
21 	
22 	    constructor(t: string, p: number) {
23 	        this.title = t;
24 	        this._price = p;
25 	    }
26 	}
27 	
28 	const product = new Product('Example Product', 100);
29 	product.price = 150;


В.3 Декоратор властивості
1 	function Property(value: any, context: ClassFieldDecoratorContext<any, any>) {
2 	    console.log('Property decorator!');
3 	    console.log('Context:', context);
4 	    return value;
5 	  }
6 	  
7 	  class ProductWithProperty {
8 	    @Property
9 	    title: string = 'Default';
10 	  
11 	    constructor(title: string) {
12 	      this.title = title;
13 	    }
14 	  }


В.4 Декоратор із параметрами (мінімальна довжина рядка)
1 	function MinLength(length: number) {
2 	  return function (value: undefined, context: ClassFieldDecoratorContext) {
3 	    return function (initialValue: string) {
4 	      if (typeof initialValue !== "string") {
5 	        throw new Error(`Property '${String(context.name)}' must be a string.`);
6 	      }
7 	      if (initialValue.length < length) {
8 	        throw new Error(`Property '${String(context.name)}' must be at least ${length} characters long.`);
9 	      }
10 	      return initialValue;
11 	    };
12 	  };
13 	}
14 	
15 	class User {
16 	  @MinLength(5)
17 	  password: string = "12345";
18 	}
19 	
20 	const user = new User();
21 	console.log(user.password);


В.5 Декоратор для методу з вимірюванням часу виконання
1 	function measure<This, Args extends any[], Return>(
2 	  value: (this: This, ...args: Args) => Return,
3 	  context: ClassMethodDecoratorContext<This, (this: This, ...args: Args) => Return>
4 	) {
5 	  return function (this: This, ...args: Args): Return {
6 	    const start = performance.now();
7 	    const result = value.apply(this, args);
8 	    const finish = performance.now();
9 	    console.log(`Execution time: ${finish - start} milliseconds`);
10 	    return result;
11 	  };
12 	}
13 	
14 	class Calculator {
15 	  @measure
16 	  fibonacci(n: number): number {
17 	    if (n <= 1) return n;
18 	    return this.fibonacci(n - 1) + this.fibonacci(n - 2);
19 	  }
20 	}
21 	
22 	const calc = new Calculator();
23 	console.log(calc.fibonacci(10));